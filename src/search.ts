import { EnrichedEmoji, EmojiData } from './types';
import allEmojisData from './emojis-expanded.json'; // Import the JSON directly

// Characters that might be the end of a common emoticon (missing the leading ':')
const partialEmoticonChars = new Set([')', '(', 'p', 'd', '/', '\\', 'o', '|', ']', '[']);

// Assign the imported data and pre-compute known emoticons
let allEmojis: EmojiData = [];
const knownEmoticons = new Set<string>();
const knownTextSymbolsToFilter = new Set<string>(['â˜º']); // U+263A

// Basic validation after import
try {
  if (Array.isArray(allEmojisData)) {
    allEmojis = allEmojisData as EmojiData;
    // Pre-compute all known emoticons from the dataset
    for (const emoji of allEmojis) {
      for (const emoticon of emoji.emoticons) {
        knownEmoticons.add(emoticon.toLowerCase());
      }
    }
  } else {
    console.error('Error: Imported emojis-expanded.json is not a valid JSON array.');
    allEmojis = []; // Reset to empty on invalid format
  }
} catch (error) {
  console.error('Error processing imported emoji data:', error);
  allEmojis = []; // Reset to empty on error
}

/**
 * Searches for emojis based on a query string using enriched metadata.
 * Prioritizes visual matches over text emoticons.
 * Filters out specific text symbols if the query is an emoticon.
 * @param query The search query.
 * @param maxResults Optional limit for the number of results.
 * @returns An array of matching emojis, sorted by relevance (score).
 */
export function searchEmojis(query: string, maxResults: number = 50): EnrichedEmoji[] {
  const lowerCaseQuery = query.toLowerCase().trim();

  if (!lowerCaseQuery || allEmojis.length === 0) {
    return [];
  }

  // Check if the query might be a partial emoticon (e.g., ')' instead of ':)')
  let potentialFullEmoticon: string | null = null;
  if (lowerCaseQuery.length === 1 && partialEmoticonChars.has(lowerCaseQuery)) {
      potentialFullEmoticon = ':' + lowerCaseQuery;
  }

  // Determine if the exact query is a known emoticon
  const queryIsKnownEmoticon = knownEmoticons.has(lowerCaseQuery) || (potentialFullEmoticon && knownEmoticons.has(potentialFullEmoticon));

  // Use Map to store unique emojis and their highest score
  const results = new Map<string, { emoji: EnrichedEmoji, score: number }>();

  for (const emoji of allEmojis) {
    let currentMaxScore = 0;

    // --- Scoring Logic --- (Higher score is better)
    const HIGH_SCORE = 2;
    const LOW_SCORE = 1;

    // 1. Exact country code match (only for short queries)
    if (lowerCaseQuery.length <= 3 && emoji.country_code === lowerCaseQuery.toUpperCase()) {
       currentMaxScore = Math.max(currentMaxScore, HIGH_SCORE);
    }

    // 2. Exact tag match
    if (emoji.tags.includes(lowerCaseQuery)) {
        currentMaxScore = Math.max(currentMaxScore, HIGH_SCORE);
    }

    // 3. Partial match in name
    if (emoji.name.toLowerCase().includes(lowerCaseQuery)) {
      currentMaxScore = Math.max(currentMaxScore, HIGH_SCORE);
    }

    // 4. Partial match in keywords
    if (emoji.keywords.some(kw => kw.includes(lowerCaseQuery))) {
      currentMaxScore = Math.max(currentMaxScore, HIGH_SCORE);
    }

    // 5. Case-insensitive full emoticon match (original query)
    if (emoji.emoticons.some(emoticon => emoticon.toLowerCase() === lowerCaseQuery)) {
      currentMaxScore = Math.max(currentMaxScore, LOW_SCORE);
    }

    // 6. Check potential full emoticon generated by heuristic
    if (potentialFullEmoticon && emoji.emoticons.some(emoticon => emoticon.toLowerCase() === potentialFullEmoticon)) {
        currentMaxScore = Math.max(currentMaxScore, LOW_SCORE);
    }

    // --- Add to results if a score was assigned --- 
    if (currentMaxScore > 0) {
        const existing = results.get(emoji.emoji);
        // Add if new, or update if the new score is higher than the existing score
        if (!existing || currentMaxScore > existing.score) {
            results.set(emoji.emoji, { emoji, score: currentMaxScore });
        }
    }

    // Optimization: If we have enough high-scoring results already, we might stop early?
    // (For now, let's process all to ensure comprehensive results)
  }

  // Convert map values to an array and sort by score (descending)
  let sortedResults = Array.from(results.values())
    .sort((a, b) => b.score - a.score) // Sort by score descending
    .map(item => item.emoji); // Extract just the emoji object

  // --- Filtering Step ---
  // If the original query was an emoticon, filter out known text-style symbols
  if (queryIsKnownEmoticon) {
      sortedResults = sortedResults.filter(emoji => !knownTextSymbolsToFilter.has(emoji.emoji));
  }

  // Take top results
  return sortedResults.slice(0, maxResults);
} 