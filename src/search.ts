import { EnrichedEmoji, EmojiData } from './types';
import allEmojisData from './emojis-expanded.json'; // Import the JSON directly

// Characters that might be the end of a common emoticon (missing the leading ':')
const partialEmoticonChars = new Set([')', '(', 'p', 'd', '/', '\\', 'o', '|', ']', '[']);

// Assign the imported data
let allEmojis: EmojiData = [];

// Basic validation after import
try {
  if (Array.isArray(allEmojisData)) {
    allEmojis = allEmojisData as EmojiData;
  } else {
    console.error('Error: Imported emojis-expanded.json is not a valid JSON array.');
    allEmojis = []; // Reset to empty on invalid format
  }
} catch (error) {
  console.error('Error processing imported emoji data:', error);
  allEmojis = []; // Reset to empty on error
}

/**
 * Searches for emojis based on a query string using enriched metadata.
 * Prioritizes visual matches over text emoticons.
 * @param query The search query.
 * @param maxResults Optional limit for the number of results.
 * @returns An array of matching emojis, sorted by relevance (score).
 */
export function searchEmojis(query: string, maxResults: number = 50): EnrichedEmoji[] {
  const lowerCaseQuery = query.toLowerCase().trim();

  if (!lowerCaseQuery || allEmojis.length === 0) {
    return [];
  }

  // Check if the query might be a partial emoticon (e.g., ')' instead of ':)')
  let potentialFullEmoticon: string | null = null;
  if (lowerCaseQuery.length === 1 && partialEmoticonChars.has(lowerCaseQuery)) {
      potentialFullEmoticon = ':' + lowerCaseQuery;
  }

  // Use Map to store unique emojis and their highest score
  const results = new Map<string, { emoji: EnrichedEmoji, score: number }>();

  for (const emoji of allEmojis) {
    let currentMaxScore = 0;

    // --- Scoring Logic --- (Higher score is better)
    const HIGH_SCORE = 2;
    const LOW_SCORE = 1;

    // 1. Exact country code match (only for short queries)
    if (lowerCaseQuery.length <= 3 && emoji.country_code === lowerCaseQuery.toUpperCase()) {
       currentMaxScore = Math.max(currentMaxScore, HIGH_SCORE);
    }

    // 2. Exact tag match
    if (emoji.tags.includes(lowerCaseQuery)) {
        currentMaxScore = Math.max(currentMaxScore, HIGH_SCORE);
    }

    // 3. Partial match in name
    if (emoji.name.toLowerCase().includes(lowerCaseQuery)) {
      currentMaxScore = Math.max(currentMaxScore, HIGH_SCORE);
    }

    // 4. Partial match in keywords
    if (emoji.keywords.some(kw => kw.includes(lowerCaseQuery))) {
      currentMaxScore = Math.max(currentMaxScore, HIGH_SCORE);
    }

    // 5. Case-insensitive full emoticon match (original query)
    if (emoji.emoticons.some(emoticon => emoticon.toLowerCase() === lowerCaseQuery)) {
      currentMaxScore = Math.max(currentMaxScore, LOW_SCORE);
    }

    // 6. Check potential full emoticon generated by heuristic
    if (potentialFullEmoticon && emoji.emoticons.some(emoticon => emoticon.toLowerCase() === potentialFullEmoticon)) {
        currentMaxScore = Math.max(currentMaxScore, LOW_SCORE);
    }

    // --- Add to results if a score was assigned --- 
    if (currentMaxScore > 0) {
        const existing = results.get(emoji.emoji);
        // Add if new, or update if the new score is higher than the existing score
        if (!existing || currentMaxScore > existing.score) {
            results.set(emoji.emoji, { emoji, score: currentMaxScore });
        }
    }

    // Optimization: If we have enough high-scoring results already, we might stop early?
    // (For now, let's process all to ensure comprehensive results)
  }

  // Convert map values to an array, sort by score (descending), then take top results
  const sortedResults = Array.from(results.values())
    .sort((a, b) => b.score - a.score) // Sort by score descending
    .slice(0, maxResults)
    .map(item => item.emoji); // Extract just the emoji object

  return sortedResults;
} 